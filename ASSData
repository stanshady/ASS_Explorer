package ASSExplorer;

import java.text.DecimalFormat;

// Stores data (numSolutions, sides, angles, altitude, etc) for ASS
// All data is UNSCALED!!!
public class ASSData {
    private int numSolutions;

    //angles
    private double swingAngle, sideAngleLong, sideAngleShort, baseAngleLong, baseAngleShort;
    private final double SWING_ANGLE_RADIAN;

    //side lengths
    private double swingLen, baseLenShort, baseLenLong, sideLen, altitudeLen;

    ASSData(double angle, double sideLen, double swingLen) {
        swingAngle = angle;
        this.sideLen = sideLen;
        this.swingLen = swingLen;
        SWING_ANGLE_RADIAN = swingAngle * Math.PI / 180;
        altitudeLen = sideLen * Math.sin(SWING_ANGLE_RADIAN);

        //initializes numSolutions and the rest of the sides,angles
        solveASS();
    }

    // Solve how many solutions then call appropriate method.
    // This method initializes numSolutions.
    private void solveASS() {
        //obtuse and rt angle case
        if (swingAngle >= 90) {
            if (swingLen > sideLen)
                numSolutions = 1;
            else
                numSolutions = 0;
        }
        // acute case
        else {
            // rt angle case.  Use a tolerance.
            if (Math.abs(swingLen - altitudeLen) <= 0.00001)
                numSolutions = 1;
            else if (swingLen >= sideLen)
                numSolutions = 1;
            else if ((swingLen > altitudeLen) && (swingLen < sideLen))
                numSolutions = 2;
            else
                numSolutions = 0;
        }

        //call appropriate method
        switch (numSolutions) {
            case 1:
                solve1Sides();
                break;
            case 2:
                solve2Sides();
                break;
            default:
                break;
        }
    }

    //Law of sines. Initializes only baseLenLong, baseAngleLong, sideAngleLong.
    //Leaves baseLenShort, baseAngleShort, sideAngleShort == 0
    private void solve1Sides() {
        double sideAngleLong_Radian = Math.asin(sideLen * Math.sin(SWING_ANGLE_RADIAN) / swingLen);
        sideAngleLong = sideAngleLong_Radian * 180 / Math.PI;

        double baseAngleLong_Radian = Math.PI - SWING_ANGLE_RADIAN - sideAngleLong_Radian;
        baseAngleLong = 180 - swingAngle - sideAngleLong;

        baseLenLong = Math.sin(baseAngleLong_Radian) * swingLen / Math.sin(SWING_ANGLE_RADIAN);
    }

    //Law of sines to initialize the rest
    private void solve2Sides() {
        double sideAngleLong_Radian = Math.asin(sideLen * Math.sin(SWING_ANGLE_RADIAN) / swingLen);
        double sideAngleShort_Radian = (Math.PI - sideAngleLong_Radian);

        sideAngleLong = sideAngleLong_Radian * 180 / Math.PI;
        sideAngleShort = sideAngleShort_Radian * 180 / Math.PI;

        double baseAngleLong_Radian = Math.PI - SWING_ANGLE_RADIAN - sideAngleLong_Radian;
        double baseAngleShort_Radian = Math.PI - SWING_ANGLE_RADIAN - sideAngleShort_Radian;
        baseAngleLong = 180 - swingAngle - sideAngleLong;
        baseAngleShort = 180 - swingAngle - sideAngleShort;

        baseLenLong = Math.sin(baseAngleLong_Radian) * swingLen / Math.sin(SWING_ANGLE_RADIAN);
        baseLenShort = Math.sin(baseAngleShort_Radian) * swingLen / Math.sin(SWING_ANGLE_RADIAN);
    }

    //returns reason for numSolutions
    public String diagnosis() {
        //obtuse or rt cases
        if (swingAngle >= 90) {
            if (numSolutions == 0)
                return numSolutions + " triangles.\n" +
                        "Angle is not acute but the Opposite Side is too short.\n" +
                        "A >= 90 but a <= b";
            else //numSolutions == 1
                return numSolutions + " triangle.\n" +
                        "Angle is not acute and the Opposite Side is long enough to reach.\n" +
                        "A >= 90 and a > b";
        } else { //swingAngle < 90
            if (numSolutions == 0)
                return numSolutions + " triangles.\n" +
                        "Angle is acute but the opposite side is too short because it's less than the altitude.\n" +
                        "A < 90 but a < altitude: a < b*sin(A)";
            else if (numSolutions == 1) {
                if (Math.abs(swingLen - altitudeLen) <= 0.00001) //close enough?
                    return numSolutions + " triangle.\n" +
                            "Angle is acute and the opposite side is equal to the altitude. It is a right triangle.\n" +
                            "A < 90 and a = altitude: a = b*sin(A)";
                else //swingLen > sideLen
                    return numSolutions + " triangle.\n" +
                            "Angle is acute and the opposite side is greater than or equal to the adjacent side.\n" +
                            "A < 90 and a >= b";
            } else //numSolutions == 2 {
                return numSolutions + " triangles.\n" +
                        "Angle is acute and the opposite side is greater than the altitude but less than the adjacent side.\n" +
                        "A < 90 and b*sin(A) < a < b.";
        }
    }

    // Used in SolveStage
    public String solutionTextLong() {
        String ret = "";

        if (swingAngle == 90)
            ret += "Right Triangle:\n";
        else if (swingAngle > 90)
            ret += "Obtuse Triangle:\n";
        else
            ret += "Acute Triangle:\n";

        ret += "A = " + formatDecimals(swingAngle) + ", " +
                "C = " + formatDecimals(baseAngleLong) + ", " +
                "B = " + formatDecimals(sideAngleLong) + "\n";
        ret += "a = " + formatDecimals(swingLen) + ", " +
                "c = " + formatDecimals(baseLenLong) + ", " +
                "b = " + formatDecimals(sideLen) + "\n";

        return ret;
    }

    // Only used when numSolutions == 2
    // Used in SolveStage
    public String solutionTextShort() {
        String ret = "";

        ret += "Obtuse Triangle:\n" +
                "A = " + formatDecimals(swingAngle) + ", " +
                "C = " + formatDecimals(baseAngleShort) + ", " +
                "B = " + formatDecimals(sideAngleShort) + "\n";
        ret += "a = " + formatDecimals(swingLen) + ", " +
                "c = " + formatDecimals(baseLenShort) + ", " +
                "b = " + formatDecimals(sideLen) + "\n";

        return ret;
    }

    public String formatDecimals(double num) {
        DecimalFormat df = new DecimalFormat("#.###");
        return df.format(num);
    }

    // never used
    public String toString() {
        String ret = "";

        ret += "numSolutions = " + numSolutions + ", altitudeLen = " + formatDecimals(altitudeLen) + "\n";
        ret += "********************\n";
        ret += "Acute Triangle:\n" +
                "A = " + formatDecimals(swingAngle) + ", " +
                "C = " + formatDecimals(baseAngleLong) + ", " +
                "B = " + formatDecimals(sideAngleLong) + "\n";
        ret += "a = " + formatDecimals(swingLen) + ", " +
                "c = " + formatDecimals(baseLenLong) + ", " +
                "b = " + formatDecimals(sideLen) + "\n";
        ret += "********************\n";
        ret += "Obtuse Triangle: \n";
        ret += "A = " + formatDecimals(swingAngle) + ", " +
                "C = " + formatDecimals(baseAngleShort) + ", " +
                "B = " + formatDecimals(sideAngleShort) + "\n";
        ret += "a = " + formatDecimals(swingLen) + ", " +
                "c = " + formatDecimals(baseLenShort) + ", " +
                "b = " + formatDecimals(sideLen) + "\n";
        ret += "********************\n";
        return ret;
    }

    // Getters.  Actually important here.
    public double getSwingAngle() {
        return swingAngle;
    }

    public double getSideAngleLong() {
        return sideAngleLong;
    }

    public double getSideAngleShort() {
        return sideAngleShort;
    }

    public double getBaseAngleShort() {
        return baseAngleShort;
    }

    public double getBaseAngleLong() {
        return baseAngleLong;
    }

    public double getSwingLen() {
        return swingLen;
    }

    public double getBaseLenShort() {
        return baseLenShort;
    }

    public double getBaseLenLong() {
        return baseLenLong;
    }

    public double getSideLen() {
        return sideLen;
    }

    public double getAltitudeLen() {
        return altitudeLen;
    }

    public int getNumSolutions() {
        return numSolutions;
    }
}
