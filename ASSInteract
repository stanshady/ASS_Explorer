package ASSExplorer;

import javafx.scene.Cursor;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.*;
import javafx.scene.transform.Rotate;

public class ASSInteract extends Pane {

    //Angle,Side,Side with angle bottom left on
    //horizontal base and then going clockwise.
    private double angle, sideLen, swingLen;

    private Line base, side, swing, shortGreen, longGreen, altitude;
    private Circle circle; //add fatter dashed lined circle?
    private Rectangle longSwingRectangle, shortSwingRectangle, rightAngleRectangle;
    private final double SCALE_FACTOR;
    private final double ANGLE_RADIAN;
    private double rectangleAngle; //don't think I want rectangleAngle global
    private ASSData data;
    private boolean dragOn; //probably already exists



    ASSInteract(double angle, double sideLen, double swingLen) {
        dragOn = false;//move lower?

        setPrefSize(800, 800);
        //ASS inputs
        this.angle = angle;
        this.sideLen = sideLen;
        this.swingLen = swingLen;

        ANGLE_RADIAN = angle * Math.PI / 180;

        data = new ASSData(angle,sideLen,swingLen);

        //initializes base as well
        SCALE_FACTOR = setUpScaleAndBase();

        setUpSide();

        //swing's endX,endY is bound to circle in setUpCircle()
        setUpSwing();

        //also initializes rightAngleRectangle
        setUpAltitude();

        setUpLongGreen();

        //Up to here...rewrite using Data
        setUpShortGreen();

        double acuteOppositeSide = Math.asin(Math.sin(ANGLE_RADIAN) * sideLen / swingLen);
        double obtuseOppositeSide = Math.PI - acuteOppositeSide;
        double shortGreenXDelta = Math.sin(Math.PI - ANGLE_RADIAN - obtuseOppositeSide) * sideLen * SCALE_FACTOR / Math.sin(obtuseOppositeSide);

        shortGreen = new Line(base.getStartX(),
                base.getStartY(),
                base.getStartX() + shortGreenXDelta,
                base.getStartY());

        shortGreen.setStroke(Color.GREEN);
        shortGreen.setStrokeWidth(3);
        shortGreen.setOpacity(0);





        //shortSwingRectangle is a linear extension of swing.
        // Used for the shortGreen intersection hold feeling.
        shortSwingRectangle = new Rectangle(swing.getStartX(), swing.getStartY(), 2000, 30);
        double angleRotateShortRectangle = obtuseOppositeSide;

        double angleNormalShort = angleRotateShortRectangle + Math.PI * 0.5;

        //readjust along the perpendicular
        //had to use setLayoutX/Y.  setX() and setY() had
        //funny behavior.
        shortSwingRectangle.setLayoutX(-1 * shortSwingRectangle.getHeight() * 0.5 * Math.cos(angleNormalShort));
        shortSwingRectangle.setLayoutY(-1 * shortSwingRectangle.getHeight() * 0.5 * Math.sin(angleNormalShort));

        Rotate rotateShort = new Rotate(angleRotateShortRectangle * 180 / Math.PI, swing.getStartX(), swing.getStartY());
        shortSwingRectangle.getTransforms().addAll(rotateShort);

        shortSwingRectangle.setOpacity(0);

        shortSwingRectangle.setOnMouseDragEntered(event -> {
            if (shortGreen.getEndX() <= base.getStartX())
                return;
            shortGreen.setOpacity(1);
            base.setOpacity(0);
            circle.setCenterX(shortGreen.getEndX());
            circle.setCenterY(shortGreen.getEndY());

        });

        shortSwingRectangle.setOnMouseDragOver(event -> {
            if (shortGreen.getEndX() <= base.getStartX())
                return;
            circle.setCenterX(shortGreen.getEndX());
            circle.setCenterY(shortGreen.getEndY());

        });

        shortSwingRectangle.setOnMouseDragExited(event -> {
            shortGreen.setOpacity(0);
            base.setOpacity(1);

            if (dragOn)
                event.consume();
                //testing
            else
                checkIntersection();
        });



        //rectangle is a linear extension of swing.
        // Used for the longGreen intersection hold feeling.
        longSwingRectangle = new Rectangle(swing.getStartX(), swing.getStartY(), 2000, 30);

        rectangleAngle = -1 * Math.atan((longGreen.getEndY() - swing.getStartY()) / (longGreen.getEndX() - swing.getStartX()));

        double normalAngle = rectangleAngle + Math.PI * 0.5;

        //readjust along the perpendicular
        //had to use setLayoutX/Y.  setX() and setY() had
        //funny behavior.
        longSwingRectangle.setLayoutX(longSwingRectangle.getHeight() * 0.5 * Math.cos(normalAngle));
        longSwingRectangle.setLayoutY(-1 * longSwingRectangle.getHeight() * 0.5 * Math.sin(normalAngle));

        Rotate rotate = new Rotate(-1 * rectangleAngle * 180 / Math.PI, swing.getStartX(), swing.getStartY());
        longSwingRectangle.getTransforms().addAll(rotate);

        longSwingRectangle.setOpacity(0);

        longSwingRectangle.setOnMouseDragEntered(event -> {
            if (longGreen.getEndX() <= base.getStartX())
                return;
            longGreen.setOpacity(1);
            base.setOpacity(0);
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());
        });

        longSwingRectangle.setOnMouseDragOver(event -> {
            if (longGreen.getEndX() <= base.getStartX())
                return;
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());

        });

        longSwingRectangle.setOnMouseDragExited(event -> {
            longGreen.setOpacity(0);
            base.setOpacity(1);

            if (dragOn)
                event.consume();
                //testing
            else
                checkIntersection();
        });

        base.getStrokeDashArray().addAll(20d, 10d);

        swing.setStrokeWidth(3);
        side.setStrokeWidth(3);

        swing.setStroke(Color.RED);
        side.setStroke(Color.BLUE);


        circle = new Circle(swing.getEndX(), swing.getEndY(), 7);


        swing.endXProperty().bind(circle.centerXProperty());
        swing.endYProperty().bind(circle.centerYProperty());

        //circle.centerXProperty().bind(swing.endXProperty());
        //circle.centerYProperty().bind(swing.endYProperty());

        circle.setCursor(Cursor.HAND);

        circle.setOnMousePressed(event -> {
            dragOn = true;
            circle.setMouseTransparent(true);
        });

        circle.setOnMouseReleased(event -> {
            circle.setMouseTransparent(false);

            //testing
            dragOn = false;

            checkIntersection();
        });


        circle.setOnMouseDragged(event -> {
            double xDiff = event.getSceneX() - swing.getStartX();
            double yDiff = event.getSceneY() - swing.getStartY();
            double hypotenuse = Math.sqrt(yDiff * yDiff + xDiff * xDiff);

            circle.setCenterX(swing.getStartX() + swingLen * SCALE_FACTOR * xDiff / hypotenuse);
            circle.setCenterY(swing.getStartY() + swingLen * SCALE_FACTOR * yDiff / hypotenuse);
        });

        circle.setOnMouseEntered(event -> {
            //change the z-coordinate of the circle
            circle.toFront();
            circle.setOpacity(1);
        });

        //this is vital. Learn more about it
        circle.setOnDragDetected(event -> {
            circle.startFullDrag();
        });


        //testing
        Arc arc = new Arc();
        arc.setCenterX(base.getStartX());
        arc.setCenterY(base.getStartY());
        arc.setRadiusX(30.0f);
        arc.setRadiusY(30.0f);
        arc.setStartAngle(0);
        arc.setLength(angle);
        arc.setType(ArcType.OPEN);
        arc.setFill(null);
        arc.setStroke(Color.RED);
        arc.setStrokeWidth(4);

        getChildren().addAll(arc, altitude, swing, base, side, longGreen, shortGreen, circle, longSwingRectangle, shortSwingRectangle, rightAngleRectangle);
    }

    //return is used to initialize SCALE_FACTOR.
    //Auto-scales and initializes base
    //as a function of angle, sideLen, swingLen.
    //Positions and scales base such that user can
    //rotate swing completely.
    public double setUpScaleAndBase() {
        double yMin, yMax, xMin, xMax, yWidth, xWidth, scaleFactor;

        //yWidth is the necessary minimum width
        yMin = Math.min(0, sideLen * Math.sin(ANGLE_RADIAN) - swingLen);
        yMax = sideLen * Math.sin(ANGLE_RADIAN) + swingLen;
        yWidth = yMax - yMin;

        //xWidth is the necessary minimum width
        xMin = Math.min(0, sideLen * Math.cos(ANGLE_RADIAN) - swingLen);
        xMax = Math.max(0, sideLen * Math.cos(ANGLE_RADIAN) + swingLen);
        xWidth = xMax - xMin;

        //720 = 0.9*800  Use 90% so there is buffer.
        //Use max(xWidth,yWidth) to scale window to make
        //sure everything fits.
        scaleFactor = 720 / Math.max(xWidth, yWidth);

        //Position base so that swing can rotate completely.
        //Want to improve in the future especially for obtuse case.
        base = new Line();
        if (xMin == 0)
            base.setStartX(50);
        else
            base.setStartX(-1 * xMin * scaleFactor + 50);
        if (yMin == 0)
            base.setStartY(750);
        else
            base.setStartY(750 + yMin * scaleFactor);
        base.setEndX(780);
        base.setEndY(base.getStartY());

        return scaleFactor;
    }

    private void setUpSide() {
        side = new Line(base.getStartX(),
                base.getStartY(),
                base.getStartX() + sideLen * SCALE_FACTOR * Math.cos(ANGLE_RADIAN),
                base.getStartY() - sideLen * SCALE_FACTOR * Math.sin(ANGLE_RADIAN));
    }

    private void setUpSwing() {
        swing = new Line(side.getEndX(),
                side.getEndY(),
                side.getEndX() + swingLen * SCALE_FACTOR,
                side.getEndY());
    }

    //also initializes rightAngleRectangle
    private void setUpAltitude() {
        altitude = new Line(swing.getStartX(),
                swing.getStartY(),
                swing.getStartX(),
                base.getStartY());
        altitude.setStroke(Color.ORANGE);
        altitude.setStrokeWidth(3);
        altitude.setOpacity(0);

        rightAngleRectangle = new Rectangle(altitude.getEndX(),
                altitude.getEndY() - 10,
                10,
                10);
        rightAngleRectangle.setFill(null);
        rightAngleRectangle.setStroke(Color.ORANGE);
        rightAngleRectangle.setStrokeWidth(2);
        rightAngleRectangle.setOpacity(0);
    }

    public void showAltitude() {
        altitude.setOpacity(1);
        rightAngleRectangle.setOpacity(1);
    }

    public void hideAltitude() {
        altitude.setOpacity(0);
        rightAngleRectangle.setOpacity(0);
    }

    private void setUpShortGreen(){

    }

    //longGreen opacity set to 1 when mouse
    //intersects (and subsequently "locks")
    // with shortSwingRectangle.
    private void setUpLongGreen(){
        //solve for long intersection of swing and base
        double deltaY = swing.getStartY() - base.getStartY();
        double deltaX = Math.sqrt(swingLen * SCALE_FACTOR * swingLen * SCALE_FACTOR - deltaY * deltaY);

        longGreen = new Line(base.getStartX(),
                base.getStartY(),
                swing.getStartX() + deltaX,
                base.getStartY());

        longGreen.setStroke(Color.GREEN);
        longGreen.setStrokeWidth(3);
        longGreen.setOpacity(0);
    }

    //slick way to check shape intersection.
    //.intersect() creates the Shape of the intersection.
    //We check if that shape has actual width (!= -1)
    public void checkIntersection() {
        Shape intersectLong = Shape.intersect(circle, longSwingRectangle);
        Shape intersectShort = Shape.intersect(circle, shortSwingRectangle);

        //check longGreen intersection
        if (intersectLong.getBoundsInLocal().getWidth() != -1) {
            if (longGreen.getEndX() < base.getStartX())
                return;
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());
            longGreen.setOpacity(1);
            base.setOpacity(0);
        }

        //check shortGreen intersection
        else if (intersectShort.getBoundsInLocal().getWidth() != -1) {
            if (shortGreen.getEndX() < base.getStartX())
                return;
            circle.setCenterX(shortGreen.getEndX());
            circle.setCenterY(shortGreen.getEndY());
            shortGreen.setOpacity(1);
            base.setOpacity(0);
        } else {
            longGreen.setOpacity(0);
            base.setOpacity(1);
        }
    }

    public double dist(Line line) {
        return Math.sqrt((line.getEndX() - line.getStartX()) * (line.getEndX() - line.getStartX()) +
                (line.getEndY() - line.getStartY()) * (line.getEndY() - line.getStartY()));
    }
}
